package com.entwicklerheld.applications.object.core;

import com.entwicklerheld.applications.object.core.construct.Initialized;
import com.entwicklerheld.applications.object.exception.InvalidNodeConfigurationException;
import com.entwicklerheld.applications.object.exception.InvalidNodeReferenceException;
import com.entwicklerheld.applications.object.exception.InvalidRootNodeException;
import com.entwicklerheld.applications.object.objects.edge.Edge;
import com.entwicklerheld.applications.object.objects.node.DecisionNode;
import lombok.*;
import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ObjectUtils;
import org.apache.commons.lang3.StringUtils;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;
import reactor.core.publisher.SynchronousSink;
import reactor.core.scheduler.Scheduler;
import reactor.core.scheduler.Schedulers;

import java.io.Closeable;
import java.security.SecureRandom;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentSkipListSet;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.function.Function;

/**
 * Abstract class representing an Ordered Binary Decision Diagram (OBDD) graph structure.
 * OBDDs are commonly used in decision-making processes or logic operations, and this
 * class supports graph traversal, cycle detection, parallel processing, and edge generation
 * between nodes.
 *
 * @param <L> The type of the subclass extending {@code AbstractOBDDGraph}
 * @param <O> The type of OBDDNode handled by this graph
 * @param <T> The type of the OBDDObject associated with the graph's nodes
 */
@Getter
@Slf4j
public abstract class AbstractOBDDGraph<L extends AbstractOBDDGraph<L, O, T>,
        O extends OBDDNode, T extends OBDDObject<T, ?>>
        extends OBDDObject<L, T>
        implements Closeable, Initialized {

    /**
     * Scheduler used for parallel execution when traversing and processing nodes.
     * Using {@link Schedulers#parallel()}, it allows tasks to be distributed across multiple
     * threads, ensuring better performance in multithreaded environments.
     */
    @Getter(AccessLevel.PROTECTED)
    protected final Scheduler scheduler = Schedulers.parallel();

    /**
     * A thread-safe map representing the unique table for the OBDD nodes.
     * The unique table is used to ensure that no duplicate nodes exist in the graph.
     * The key is an integer reference to the node, and the value is the {@link OBDDNode}.
     */
    @EqualsAndHashCode.Exclude
    private final Map<Integer, OBDDNode> uniqueTable = new ConcurrentHashMap<>();

    @Setter
    private OBDDObject<?, ?> root = null;
    /**
     * A list of OBDD objects (nodes) in the graph. This list is populated when the graph
     * is initialized or traversed.
     */
    @EqualsAndHashCode.Exclude
    private List<OBDDObject<?, ?>> nodes = new CopyOnWriteArrayList<>();

    /**
     * A list of edges representing connections between nodes in the graph.
     * Each edge represents a directed relationship between two nodes.
     */
    private List<Edge> edges = new CopyOnWriteArrayList<>();

    private boolean isInitialized = false;

    /**
     * Enumeration representing the direction in which the graph is traversed.
     * The {@code TOP_DOWN} direction traverses from a node to its branches,
     * while the {@code BOTTOM_UP} direction traverses from branches back to the parent node.
     */
    @Getter
    @AllArgsConstructor
    public enum TraversalDirection {
        TOP_DOWN(OBDDObject::getBranches),
        BOTTOM_UP(OBDDObject::getParentsAsSet);

        private final Function<OBDDObject<?, ?>, Collection<OBDDObject<?, ?>>> next;
    }

    /**
     * Abstract method that resolves a node reference into a specific {@link OBDDNode}.
     * Implementing classes must provide logic to resolve the node from a reference.
     *
     * @param nodeReference An integer representing the node reference.
     * @return The resolved {@link OBDDNode}.
     * @throws InvalidNodeReferenceException If the node reference is invalid or cannot be resolved.
     */
    protected abstract Optional<O> resolveNodeReference(int nodeReference) throws InvalidNodeReferenceException;

    /**
     * Initializes the graph by transforming and traversing the nodes and edges
     * in the OBDD structure.
     * <p>
     * Nodes are processed in a top-down manner, and edges are generated by
     * traversing between node branches.
     */
    @Override
    public void init() {
        this.nodes = transformNodes(e -> uniqueObddObjects(e, TraversalDirection.BOTTOM_UP));
        this.edges = transformNodes(this::generateEdges);

        if (Objects.isNull(this.root)) {
            this.root = findRootNode().block();
        } else if(!this.root.getParentsAsSet().contains(this) || this.root.getParentsAsSet().size() > 1) {
            throw new InvalidRootNodeException("Root node is not a single OBDD node");
        }
        isInitialized = true;
    }

    /**
     * Transforms a list of OBDD objects into another type using a provided function
     * that returns a {@link Flux}. The method processes the graph entries in parallel
     * and applies the function to each node.
     *
     * @param function The function to apply to each OBDDObject.
     * @param <S>      The type of the result after applying the transformation.
     * @return A list of transformed objects.
     */
    private <S> List<S> transformNodes(Function<OBDDObject<?, ?>, Flux<S>> function) {
        List<S> list = new CopyOnWriteArrayList<>();

        // Process graph entries in parallel and transform them
        Flux.fromIterable(retrieveGraphEntries())
                .parallel()
                .runOn(scheduler)
                .filter(Objects::nonNull)
                .map(Map.Entry::getValue)
                .flatMap(function)
                .doOnNext(list::add)
                .sequential()
                .blockLast();

        return list;
    }

    /**
     * Retrieves all entries from the unique table of OBDD nodes.
     * Each entry represents a key-value pair, where the key is the integer reference
     * and the value is the {@link OBDDNode}.
     *
     * @return An iterable of map entries representing the nodes in the unique table.
     */
    private Iterable<Map.Entry<Integer, OBDDNode>> retrieveGraphEntries() {
        return () -> this.getUniqueTable().entrySet().iterator();
    }

    /**
     * Generates edges for a given {@link OBDDObject}. Each edge connects a node
     * to its true and false branches, creating two edges for each node.
     *
     * @param node The {@link OBDDObject} (usually a {@link DecisionNode}) from which to generate edges.
     * @return A {@link Flux} emitting two {@link Edge} objects (one for the true branch and one for the false branch).
     * @throws InvalidRootNodeException If the node has invalid or null branches or lacks valid parent nodes.
     */
    public Flux<Edge> generateEdges(OBDDObject<?, ?> node) {
        // Ensure that the node has valid references for its true and false branches
        if (node.getParentsAsSet().isEmpty() || ObjectUtils.anyNull(node.getTrueBranch(), node.getFalseBranch())) {
            String message = "DecisionNode [%s] must reference another Node. TrueBranch [%s] FalseBranch [%s] or Parent [%s] is null";

            throw new InvalidNodeConfigurationException(String.format(message,
                    node, node.getTrueBranch(), node.getFalseBranch(),
                    StringUtils.join(node.getParentsAsSet(), ", ")));
        }

        // Generate and emit edges for both the true and false branches
        return Flux.just(
                new Edge(node, node.getTrueBranch(), true),
                new Edge(node, node.getFalseBranch(), false)
        );
    }

    /**
     * Traverses the OBDD structure starting from the given node. The traversal
     * direction can be either top-down or bottom-up. The method generates a
     * {@link Flux} of unique OBDD objects by visiting each node in the graph
     * and ensuring that no node is visited more than once.
     *
     * @param start              The starting {@link OBDDObject} for the traversal.
     * @param traversalDirection The direction in which to traverse the graph
     *                           (either TOP_DOWN or BOTTOM_UP).
     * @return A {@link Flux} emitting unique OBDD objects as they are traversed.
     */
    protected Flux<OBDDObject<?, ?>> uniqueObddObjects(OBDDObject<?, ?> start, AbstractOBDDGraph.TraversalDirection traversalDirection) {

        return Flux.generate(() -> new TraversalState(start), (TraversalState state, SynchronousSink<OBDDObject<?, ?>> sink) -> {

            // Retrieve the current node from the traversal state
            OBDDObject<?, ?> current = state.getCurrentNode();

            // Check if the current node has already been visited to avoid cycles
            if (!state.getVisited().add(current)) {
                String msg = String.format("Node [%s] has already been visited, skipping to avoid cycle.", current);
                throw new InvalidNodeReferenceException(msg);
            }
            // Emit the current node
            sink.next(current);

            // If the current node is a DecisionNode, continue traversing its branches
            if (current instanceof DecisionNode) {
                if (state.getNextNodesIterator() == null || !state.getNextNodesIterator().hasNext()) {
                    // Retrieve the next nodes based on the traversal direction
                    Collection<OBDDObject<?, ?>> nextNodes = traversalDirection.next.apply(current);

                    // If there are no further nodes to traverse, complete the Flux stream
                    if (ObjectUtils.isEmpty(nextNodes)) {
                        sink.complete();
                        return state;
                    }

                    // Set the iterator for the next nodes to traverse
                    state.setNextNodesIterator(nextNodes.iterator());
                }

                // Move to the next node in the iteration
                state.setCurrentNode(state.getNextNodesIterator().next());
            } else {
                // If the current node is not a DecisionNode, complete the traversal
                sink.complete();
            }

            return state; // Return the updated state for the next iteration
        });
    }

    /**
     * Validates whether there is exactly one DecisionNode that has this
     * AbstractOBDDGraph as its only parent and returns it as a Flux.
     *
     * @return A Flux emitting the single DecisionNode if found.
     * @throws InvalidRootNodeException If no DecisionNode or more than one
     *                                  is found, or if the parent is not
     *                                  this AbstractOBDDGraph.
     */
    protected Mono<DecisionNode> findRootNode() {
        // Create a Flux from the unique table entries and filter for DecisionNodes
        return Flux.fromIterable(uniqueTable.values())
                .filter(Objects::nonNull)
                .ofType(DecisionNode.class)
                .filter(decisionNode -> decisionNode.getParentsAsSet().contains(this))
                .collectList()
                .flatMap(decisionNodes -> {
                    if (decisionNodes.size() == 1) {
                        return Mono.just(decisionNodes.get(0)); // Emit the found DecisionNode
                    } else {
                        return Mono.error(new InvalidRootNodeException("Exactly one DecisionNode with this graph as the root is required."));
                    }
                });
    }

    /**
     * Generates a random unique ID that does not exist in the unique table of this OBDD graph.
     * <p>
     * The method utilizes a {@link SecureRandom} instance to generate random integers and
     * ensures that the generated ID is not present in the set of existing IDs stored in the
     * unique table of the graph.
     * </p>
     *
     * <p>
     * The method works as follows:
     * <ul>
     *     <li>It retrieves the current set of unique IDs from the unique table using
     *     {@link #getUniqueTable()}.</li>
     *     <li>A new random integer is generated using {@link SecureRandom#nextInt()}.</li>
     *     <li>The method checks if the generated ID already exists in the set of existing IDs.</li>
     *     <li>If the ID exists, a new random ID is generated, and the process repeats until
     *     a unique ID is found.</li>
     * </ul>
     * </p>
     *
     * <p>
     * This method is particularly useful when creating new nodes in the OBDD graph that
     * require a unique identifier, ensuring that no collisions occur with existing IDs.
     * </p>
     *
     * @return A randomly generated unique integer ID that is not present in the unique table.
     * @throws IllegalArgumentException If the random ID generation fails (though unlikely with
     *                                  a properly configured {@link SecureRandom}).
     * @see SecureRandom
     * @see #getUniqueTable()
     */
    public int getRandomID() {

        Set<Integer> ids = getUniqueTable().keySet();
        SecureRandom random = new SecureRandom();
        int newId;

        do {
            newId = random.nextInt(); // Generate a random ID
        } while (ids.contains(newId));

        return newId;
    }

    @Override
    public int hashCode() {
        return Objects.hash(getId()); // oder andere relevante Attribute
    }
}